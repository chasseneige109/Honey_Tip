## ✅ `ios::sync_with_stdio(false);`

### 무슨 뜻이야?

- C++의 `cin`, `cout`과 C의 `scanf`, `printf` 간의 **동기화(sync)를 끊는다**는 의미야.
    

### 왜 써?

- `cin`/`cout`을 더 빠르게 하기 위해.
    
- 기본적으로 C++ 표준 입출력은 C 입출력과 호환성을 유지하려고 **느리게 동작**함.
    
- 이걸 `false`로 끊으면 C++ 입출력이 C 입출력보다 거의 비슷한 속도로 **훨씬 빨라짐.**
    

### 단점?

- `scanf()`나 `printf()`와 **같이 섞어 쓰면 안 됨** → 결과가 꼬일 수 있어.
    

---

## ✅ `cin.tie(NULL);`

### 무슨 뜻이야?

- `cin`과 `cout`을 **묶지 않겠다 (tie 끊기)** 는 의미야.
    

### 왜 써?

- 원래는 `cin`을 쓸 때 `cout`이 자동으로 flush(출력) 되는데,
    
- 이걸 끊으면 **불필요한 flush를 막아서 속도가 더 빨라짐.**


## ✅ `endl` vs `\n` 차이

|구문|설명|성능|
|---|---|---|
|`endl`|줄바꿈 + **flush(버퍼 비움)**|느림 ⚠️|
|`\n`|줄바꿈만 (flush 안 함)|빠름 ✅|


### 🎯 `endl`이 느린 이유
- `cout << endl;`은 실제로 이렇게 생김:
```

cout << '\n';      // 줄바꿈 
cout.flush();      // 강제로 출력 버퍼 비움`
```

즉, **버퍼를 매번 비우는 작업**이 들어가니까 느려져.


### 실전 예시 비교

#### XXX 느린 코드 (flush 매번 발생)


```
for (int i = 0; i < 100000; i++) 
{     
	cout << i << endl; // 매번 출력 + flush 
}
```

####  OOO 빠른 코드 (버퍼 쌓아두고 한 번에 출력)



```
for (int i = 0; i < 100000; i++) 
{     
cout << i << '\n'; // 줄바꿈만 하고 flush 안 함 
}
```

속도 차이 **몇십 배 차이 날 수 있어**.

---

### ⚠️ 언제는 `endl`을 써야 할까?

- **진짜로 버퍼를 비워야 할 때** (예: 디버깅 로그, 사용자 입력 직전 안내)
    
- 터미널에 **실시간으로 출력 보여줘야 할 때**
    

그 외엔 대부분 `\n` 쓰는 게 낫다.