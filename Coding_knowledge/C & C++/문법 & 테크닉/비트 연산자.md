# ✅ 비트 연산자 종류

| 연산자  | 이름          | 설명                       | 예시 (`a=5`, `b=3`)    |
| ---- | ----------- | ------------------------ | -------------------- |
| `&`  | AND         | 둘 다 1이면 1                | `5 & 3 = 1`          |
| `\|` | OR          | 하나라도 1이면 1               | `5 \| 3 = 7`         |
| `^`  | XOR         | 다르면 1                    | `5 ^ 3 = 6`          |
| `~`  | NOT         | 비트 반전 (1→0, 0→1)         | `~5 = -6` (2의 보수 표현) |
| `<<` | Left Shift  | 왼쪽으로 n비트 이동 = `a × 2^n`  | `5 << 1 = 10`        |
| `>>` | Right Shift | 오른쪽으로 n비트 이동 = `a ÷ 2^n` | `5 >> 1 = 2`         |


# ✅ 비트 조작 라이브러리 함수
```
#include <bitset>
bitset<8> b(5); // "00000101"

b.count(); // 1의 개수 세기
b.set(2);  // 2번 비트 켜기
b.reset(2); // 끄기
b.flip(2); // 토글
b.test(2); // 켜져있는지 확인

```

# ✅ 활용 예시

---

## 1. **짝수/홀수 판별**


`if (x & 1) cout << "홀수"; else cout << "짝수";`

👉 마지막 비트가 1이면 홀수

---

## 2. **2의 거듭제곱인지 확인**


`if ((x & (x - 1)) == 0) cout << "2의 거듭제곱";`

👉 단, `x > 0`일 때만 유효

---

## 3. **비트 켜기/끄기/토글/확인**

| 목적        | 연산                                 |
| --------- | ---------------------------------- |
| k번째 비트 켜기 | `x                                 |
| k번째 비트 끄기 | `x &= ~(1 << k)`                   |
| k번째 비트 토글 | `x ^= (1 << k)`                    |
| k번째 비트 확인 | `(x >> k) & 1` 또는 `(x & (1 << k))` |

---

## 4. **비트마스크 (집합 표현)**

- 정수 하나로 **최대 32개의 on/off 상태**를 표현 가능
    


`int mask = 0;  // 2번 원소 추가 mask |= (1 << 2);  // 2번 원소 있는지 확인 if (mask & (1 << 2)) { ... }  // 2번 원소 제거 mask &= ~(1 << 2);`

---

## 5. **스왑 (XOR 트릭)**

`a ^= b; b ^= a; a ^= b;`
- 0 ^ A = A 활용 
- XOR 은 2번 하면 원래로 돌아옴 (복호화 기능)

⚠️ 자기 자신과 스왑 시 오류 가능, 실무에서는 `std::swap()`이 안정적

---

## 6. **빠른 곱셈/나눗셈**

`x << 1  // x * 2 x << n  // x * (2^n)  x >> 1  // x / 2 x >> n  // x / (2^n)`

👉 부호 없는 정수에서 안전

---

## 7. **최하위 비트만 남기기**

`x & -x`

👉 예: `x = 12 (1100) → 4 (0100)`  
→ 트리 기반 알고리즘 (Fenwick Tree 등)에서 자주 사용